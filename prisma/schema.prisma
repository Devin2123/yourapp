datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // If you hit a shadow DB permission error, uncomment:
  // shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum OrderStatus {
  PENDING
  PAID
  EXPIRED
  CANCELED
  FAILED
}

enum RoleGrantStatus {
  QUEUED
  DONE
  FAILED
}

enum PayoutStatus {
  QUEUED
  REQUESTED
  SENT
  CONFIRMED
  FAILED
}

// --- Server ---
model Server {
  id              String   @id @default(cuid())
  guildId         String   @unique
  ownerDiscordId  String
  payoutWallet    String
  chain           String   @default("POLYGON")
  splitterAddress String?
  createdAt       DateTime @default(now())

  products Product[]
  // roleGrants RoleGrant[]      // ‚ùå remove this line
  wallets  Wallet[] // ‚úÖ keep (new)
  payouts  Payout[] // ‚úÖ add this line

  @@index([guildId])
}

// --- Wallet (for seller‚Äôs per-currency addresses) ---
model Wallet {
  id        String    @id @default(cuid())
  serverId  String
  server    Server    @relation(fields: [serverId], references: [id])
  currency  String // e.g. "BTC" | "ETH" | "USDT" | "DOGE"
  address   String
  createdAt DateTime  @default(now())
  Product   Product[]

  @@unique([serverId, currency])
  @@index([serverId])
}

model Product {
  id       String @id @default(cuid())
  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)

  // üëá NEW: bind a product to a specific payout wallet
  walletId String?
  wallet   Wallet? @relation(fields: [walletId], references: [id])

  name        String
  description String?
  // price in USD cents (seller sets this)
  priceMinor  Int
  // informative copies (kept for convenience / querying)
  currency    String // should mirror wallet.asset
  chain       String  @default("POLYGON") // should mirror wallet.chain

  roleId    String?
  active    Boolean  @default(true)
  createdAt DateTime @default(now())

  orders     Order[]
  roleGrants RoleGrant[]

  @@index([serverId])
  @@index([active, createdAt])
}

model Order {
  id             String      @id @default(cuid())
  productId      String
  product        Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  buyerDiscordId String?
  invoiceId      String?     @unique
  status         OrderStatus @default(PENDING)

  // existing (native amounts)
  grossWei String?

  // optional split breakdown in "minor units" (e.g., USDC 6dp or wei for native)
  grossMinor String?
  feeMinor   String?
  netMinor   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roleGrants    RoleGrant[]
  webhookEvents WebhookEvent[]
  payouts       Payout[]

  @@index([status, updatedAt])
  @@index([invoiceId])
}

model WebhookEvent {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  deliveryId String   @unique
  type       String
  invoiceId  String?
  orderId    String?
  raw        Json

  order Order? @relation(fields: [orderId], references: [id])

  @@index([invoiceId])
  @@index([type, createdAt])
}

model RoleGrant {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  orderId   String
  productId String
  discordId String
  status    RoleGrantStatus @default(QUEUED)
  attempts  Int             @default(0)
  lastError String?

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@index([status, updatedAt])
  @@index([discordId])
}

// --- Payout (just rename relation field & add backref) ---
model Payout {
  id          String   @id @default(cuid())
  orderId     String   @unique
  serverId    String
  toAddress   String
  asset       String
  chain       String
  amountMinor String
  status      String   // or your enum
  attempts    Int      @default(0)
  lastError   String?
  txHash      String?  // you already reference this
  externalId  String?  // üëà add this
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // relations...
  Server Server @relation(fields: [serverId], references: [id])
  Order  Order  @relation(fields: [orderId], references: [id])
}